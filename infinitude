#!/usr/bin/env perl
use FindBin;
use lib "$FindBin::Bin/lib";

use Carp qw/shortmess/;
use Mojolicious::Lite;
use Mojo::JSON qw/encode_json decode_json/;
use DateTime;
use WWW::Wunderground::API;
use Try::Tiny;
use Time::HiRes qw/time/;

use Cache::FileDump;
use XML::Simple::Minded;

my $store = Cache::FileDump->new(base=>'state', _serializer=>sub{ shift }, _deserializer=>sub{ shift });

$store->set(started=>time);

our $config;
if (my $config_json = $store->get('infinitude.json')) {
	$config = decode_json($config_json);
} else {
	# Default configuration if no state/infinitude.json file is found.
	# customize config by editing state/infinitude.json
	$config = {
		wunderground_key => '044841ec6ac9c9f5',        #Weather underground API key
		serial_tty => '/dev/ttyUSB0',  #RS485 serial tty interface
		app_secret => 'Pogotudinal',   #Mojolicious cookie signature
		pass_reqs => 60*60*0           #Pass requests to Carrier webservice every 2 hours (set to 0 to disable)
	};
	$store->set('infinitude.json', encode_json($config));
}

if (defined($config->{serial_tty})) {
	if (-e $config->{serial_tty}) {
		require IO::Termios;
		require CarBus;
		warn "Using $config->{serial_tty} serial interface\n";
	} else {
		warn "Can't find serial device: $config->{serial_tty}. Serial monitoring disabled.\n";
		delete $config->{serial_tty};
	}
}

my $req_cache = Cache::FileDump->new( base=>$store->base, namespace=>'request', default_expires_in=>$config->{pass_reqs} );

app->secrets([$config->{app_secret}]);
push @{app->static->paths}, $ENV{MOJO_MODE} eq 'development' ? 'public/app' : 'public/dist';

hook before_dispatch => sub {
	my $c = shift;

	my $url = $c->req->url;
	if ($url->to_abs->host =~ /(bryant|carrier)/) {
		my $nk = $url->path->to_string;
		$nk =~ s/\//-/g;
		$nk =~ s/^-//;
		$c->stash->{action_key} = $nk;

		if ($config->{pass_reqs} and !$req_cache->get($nk)) {
			$req_cache->set($nk,time);
			my $o_req = $c->req->clone;
			my $o_url = Mojo::URL->new($o_req->url->to_abs->to_string);
			$o_url->scheme('https');
			$o_req->url($o_url);

			$c->app->log->debug("No cache for $nk. Make Carrier request");
			$store->set("req-$nk.txt", $o_req->to_string);
			my $ua = Mojo::UserAgent->new;
			my $tx = $ua->start(Mojo::Transaction::HTTP->new(req=>$o_req));
			$store->set("res-$nk.txt", $tx->res->to_string);
			$store->set("res-$nk.xml", $tx->res->body);
		}

		#Mangle Internet-bound request to self
		my $appurl = $c->url_for('/');
		$url->base($appurl->base);
		$c->app->log->debug($url);

		#Stuff data into store
		if (my $data = $c->req->param('data')) {
			my $xml;
			try {
				$xml = XML::Simple::Minded->new($data);
				my ($store_key) = $url->path  =~ /.*\/(.*)$/;
				$c->app->log->debug("Saving $store_key");
				$store->set("$store_key.raw", $data);
				$store->set("$store_key.xml" , $xml.'');
				$store->set("$store_key.json", $xml->_as_json);
				$c->stash->{data} = $xml;
				$c->stash(store_key=>$store_key);
			} catch {
				$c->stash('error','true');
				$c->app->log->debug($url, shortmess(), "Caught error: $_".$@);
				$store->set("error-".time() => 'url:'.$url."\nerror: $_\ndata:".$data);
			};
		}
	}
};

sub qtr_hr {
	my ($hour,$minute) = @_;
	if ($hour =~ /\d:\d/) {
		($hour,$minute) = $hour =~ /(\d+)\:(\d+)/;
	}
	$hour||=(localtime)[2];
	$minute||=(localtime)[1];
	$minute = 15*int(0.5+($minute/15));
	if ($minute==60) {
		$hour+=1;
		$minute=0;
	}
	return sprintf("%02d:%02d",$hour,$minute);
}

# Quick and dirty automation support. Ideally this will turn REST'y
# 	but we want to ensure automation devices eg VeraLite will work first
any '/api/:zone_id/hold' => sub {
	my $c = shift;
	my $xml = XML::Simple::Minded->new($store->get('systems.xml'));

	my $idx = ($c->stash('zone_id')||1) - 1;
	my $zone = $xml->system->config->zones->zone->[$idx];

	my $setting = {};

	$setting->{hold} = $c->req->param('hold') eq 'off' ? 'off' : 'on';
	$zone->hold([$setting->{hold}]);

	my $activities = { home=>'home', away=>'away', sleep=>'sleep', wake=>'wake', manual=>'manual' };
	$setting->{activity} = $activities->{lc($c->req->param('activity'))} || 'home';
	$zone->holdActivity([$setting->{activity}]);

	# default to about an hour from now
	$setting->{until} = &qtr_hr($c->req->param('until') || ((localtime)[2] + 1));
	$zone->otmr([$setting->{until}]);

	$store->set('systems.xml',  $xml);
	$store->set('systems.json', $xml->_as_json());
	$store->set(changes => 'true');

	$c->render(text=>$xml, format=>'xml');

	#$c->render(json=>$setting);
};

any '/api/:zone_id/activity/:activity_id' => sub {
	my $c = shift;
	my $xml = XML::Simple::Minded->new($store->get('systems.xml'));

	my $idx = ($c->stash('zone_id')||1) - 1;
	my $zone = $xml->system->config->zones->zone->[$idx];

	my $setting = {};
	foreach my $activity (@{$zone->activities->activity}) {
		if ($activity->id eq $c->stash('activity_id')) {
			foreach my $set (qw/clsp htsp fan/) {
				$activity->$set([$c->req->param($set)]) if $c->req->param($set);
			}
			$setting = decode_json($activity->_as_json);
			$store->set('systems.xml',  $xml);
			$store->set('systems.json', $xml->_as_json());
			$store->set(changes => 'true');
			last;
		}
	}

	$c->render(json=>$setting);
};

# access simple system config variables by path
any '/api/*path' => sub {
	my $c = shift;
	my $xml = XML::Simple::Minded->new($store->get('systems.xml'));
	my $search = $xml->system();
	foreach my $node (split('/',$c->stash('path'))) {
		$search = $search->$node;
	}
	my $setting = { status=>'success' };

	try {
		if (ref($search)) {
			# path returns a structure. Can modify.
			my %sets = %{$c->req->params->to_hash()};
			foreach my $key (keys %sets) {
				$search->$key([$sets{$key}]);
			}
			$setting->{data} = { %{$search->TO_JSON()} };
			$store->set('systems.xml',  $xml);
			$store->set('systems.json', $xml->_as_json());
			$store->set(changes => 'true');
		} else {
			#path is a scalar. return only.
			$setting->{data} = $search;
		}
	} catch {
		$setting->{status} = 'fail';
	};

	$c->render(json=>$setting);
};


get '/' => sub {
  my $c = shift;
  $c->reply->static('index.html');
};

get '/Alive' => sub {
	my $c = shift;
	$c->render(text=>'alive', format=>'txt');
};

get '/time' => sub {
	my $c = shift;
	my $date = DateTime->now();
	my $xml = XML::Simple::Minded->new({
		"time" => {
			version => '1.9',
			utc => [$date->strftime("%FT%TZ")]
		}
	});
	$c->render(text=>$xml, format=>'xml');
};

post '/systems/:id' => sub {
	my $c = shift;
	if ($c->stash('id') eq 'infinitude') { # Data is being saved from web client
		my $xml = XML::Simple::Minded->new($c->req->json);
		#print STDERR substr($xml.'',0,100)."\n";
		#print STDERR substr($xml->_as_json,0,100)."\n";
		#return;
		$store->set('systems.xml'  => $xml);
		$store->set('systems.json' => $xml->_as_json);
		$store->set(changes => 'true');
	} else { # Data from thermostat.
		if (!$c->stash('error')) {
			$store->set( 'systems.xml'  => $store->get($c->stash('store_key').'.xml') );
			$store->set( 'systems.json' => $store->get($c->stash('store_key').'.json') );
		}
	}
	$c->render(text=>'',format=>'txt');
};

get '/systems/:id/config' => sub {
	my $c = shift;
	my $xml = XML::Simple::Minded->new($store->get('systems.xml'));
	my $config = XML::Simple::Minded->new({config=>$xml->system->config()});
	$c->render(text=>$config, format=>'xml');
};

get '/systems/:id' => sub {
	my $c = shift;
	my $xml = $store->get('systems.xml');
	$c->app->log->debug("-------- Getting systems.xml (".$c->stash('id').") from infinitude.");
	$xml
		? $c->render(text=>$xml.'', format=>'xml')
		: $c->render(text=>'', format=>'txt');
};

any '/systems/:system_id/status' => sub {
	my $c = shift;
	my $changes = $store->get('changes') || '';
	$changes = 'true' unless $store->get('systems.xml'); #Force a change cycle if we have no stat config
	my $xml = XML::Simple::Minded->new({
		serverStatus => {
			 version => '1.6',
			pingRate => [$changes eq 'true' ? 20 : 12],
			serverHasChanges => [$changes || 'false'],
			configHasChanges => [$changes || 'false'],
		}
	});
	$c->app->log->debug("********** There are changes. ****************") if $changes;
	$store->set(changes=>'');
	$c->render(text=>$xml, format=>'xml');
};

post '/systems/:system_id/(:part)' => sub {
	my $c = shift;
	$c->render(text=>'', format=>'txt');
};

get '/weather/:zip/forecast' => sub {
	my $c = shift;
	my $xml;
	if ($config->{wunderground_key}) {
		my $wunderground = WWW::Wunderground::API->new(auto_api=>1, api_key=>$config->{wunderground_key}, location=>$c->stash('zip'), cache=>$req_cache);
		my $forecast = $wunderground->forecast10day->simpleforecast->forecastday;
		
		sub map_wx {
			my ($f) = @_;
			my @wx_status = ( 'Thunderstorms', 'Sleet', 'Rain and Sleet', 'Wintry Mix', 'Rain and Snow', 'Snow', 'Freezing Rain', 'Rain', 'Blizzard', 'Fog', 'Cloudy', 'Partly Cloudy', 'Mostly Cloudy', 'Sunny' );
			my $lookup = {};
			my $i = 0;
			foreach my $stat (@wx_status) { $lookup->{$stat} = $i++; }
			my $search = $f->{conditions}||$f->{icon};
			$search =~ s/(heavy|light|chance of|showers)//ig;
			$search =~ s/^\s+//; $search =~ s/\s+$//;

			$search = 'Thunderstorms' if $search =~ /thunder/i;
			$search = 'Sunny' if $search =~ /clear/i;
			$search = 'Cloudy' if $search =~ /overcast/i;
			$search = 'Partly Cloudy' if $search =~ /scattered clouds/i;
			$search = 'Fog' if $search =~ /fog$/i;
			$search = 'Sleet' if $search =~ /ice pellet/i;

			my $idx = $lookup->{$search};
			return ($idx, $wx_status[$idx]);
		};

		my @days = ();
		for my $i (0 .. 5) {
			my $day = $forecast->[$i];
			my $date = DateTime->from_epoch(epoch => $day->{date}{epoch}, time_zone=>$day->{date}{tz_long} );
			my ($status_id, $status_message) = &map_wx($day);
			push(@days, {
				id => $day->{date}{weekday},
				timestamp => [ $date->strftime("%FT%T%z") ],
				min_temp => [{ units=>'f', content=>$day->{low}{fahrenheit} }],
				max_temp => [{ units=>'f', content=>$day->{high}{fahrenheit} }],
				status_id => [$status_id],
				status_message => [ $status_message ],
				pop=>[ $day->{pop} ]
			});
		}

		$xml = XML::Simple::Minded->new({ weather_forecast=>{ timestamp=>[DateTime->now->iso8601.'.01234Z'], ping=>[240], day=>\@days } });
	}
	$xml||=$store->get('res-'.$c->stash('action_key').'.xml');
	$c->render(text=>$xml, format=>'xml');
};

my $handle;
my $stream;
my $carbus;
websocket '/serial' => sub {
	my $c = shift;
	if ($config->{serial_tty}) {
		$c->app->log->debug('WebSocket opened. Attempting to access '.$config->{serial_tty});
		$handle ||= IO::Termios->open($config->{serial_tty},"38400,8,n,1");
		$stream ||= Mojo::IOLoop::Stream->new($handle);
		$carbus ||= CarBus->new(async=>1);

		$stream->on(read => sub {
			my ($stream, $bytes) = @_;
			$carbus->push_stream($bytes);
			my $frame = $carbus->get_frame();
			$frame->{timestamp} = time;

			unless ($frame->{error}) {
				my $key = substr($frame->{data},0,3);
				my $registers = {
					"\x00\x02\x02" => 'Time',
					"\x00\x02\x03" => 'Date',
				};
				$frame->{field} = $registers->{$key};

				$c->send({json=>$frame});
			}
		});
		$stream->on(error=>sub {
			my ($stream, $err) = @_;
			$c->app->log->debug("ERROR $err");
		});
		$stream->on(close=>sub {
			my ($stream) = @_;
			$c->app->log->debug("Closed stream");
		});

		$c->on('finish' => sub {
			my ($c, $code) = @_;
			$c->app->log->debug("Closed: $code");
			$stream->stop if $stream;
			$stream = undef;
			$handle = undef;
		});
		$stream->start;
		$stream->reactor->start unless $stream->reactor->is_running;
	}
};

get '/:key' => sub {
	my $c = shift;
	my $store_key = join('.', $c->stash('key'), $c->stash('format'));
	$c->render(text=>$store->get($store_key));
};

app->start;
__DATA__

@@ not_found.html.ep
% my $key||='undefined';
<%= $key %> not found
